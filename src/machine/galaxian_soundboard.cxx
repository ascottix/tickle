/*
    Galaxian arcade machine emulator
    
    Soundboard emulation

    Copyright (c) 2004 Alessandro Scotti
*/
#include "galaxian_soundboard.h"

AGalaxianFireControl::AGalaxianFireControl( AChannel * ch_fire, AChannel * ch_noise ) 
{
    a_fire_ = ch_fire;
    a_noise_ = ch_noise;

    AFloat R46 = Kilo( 10 );
    AFloat R47 = Kilo( 2.2 );
    AFloat R48 = Kilo( 2.2 );
    AFloat C28 = Micro( 47 );
    AFloat C29 = Micro( 0.01 );

    c28_ = 0;
    c29_ = 0;

    a_[0] = 1 - ASE::getRCFactor( R47, C28 ); // Fire to C28 thru R47
    a_[1] = 1 - ASE::getRCFactor( R48, C29 ); // C28 to C29 thru R48
    a_[2] = 1 - ASE::getRCFactor( R46, C29 ); // Noise to C29 thru R46
    a_[3] = 1 - ASE::getRCFactor( R48, C28 ); // C29 to C28 thru R48
}

void AGalaxianFireControl::updateBuffer( AFloat * buf, unsigned len, unsigned ofs )
{
    a_fire_->updateTo( ofs );
    a_noise_->updateTo( ofs );

    AFloat * fire = a_fire_->stream() + streamSize();
    AFloat * noise = a_noise_->stream() + streamSize();

    while( len > 0 ) {
        // Charge C28 thru fire
        c28_ += (*fire - c28_) * a_[0];

        // Charge C28 thru C29
        c28_ += (c29_ - c28_) * a_[3];

        // Charge C29 thru noise
        c29_ += (*noise - c29_) * a_[2];

        // Charge C29 thru C28
        c29_ += (c28_ - c29_) * a_[1];

        // Output is voltage across C29
        *buf++ = c29_;

        fire++;
        noise++;

        len--;
    }
}

GalaxianSoundBoard::GalaxianSoundBoard()
{
    // Initialize the analog sound emulation
    a_noise_ = new AWhiteNoise( 8000 );
    a_noise_->setOutput( 3.4, 0.3 ); // 7474
    a_hit_latch_ = new ALatch; // Hit
    a_hit_diode_ = new AClipperLo( *a_hit_latch_, 0.7 ); // D1 (4148 diode)
    a_hit_ = new ACapacitorWithSwitch( *a_hit_diode_, *a_noise_, Kilo(1), Kilo(172), Micro(2.2) ); // R35+R36, C21
    a_hit_filter_ = new AActiveBandPassFilter( *a_hit_, Kilo(150), Kilo(22), Kilo(470), Micro(0.01), Micro(0.01) ); // R35, R36, R37, C22, C23, LM324
    a_hit_filter_->setGain( 2e+02 );

    a_fire_latch_ = new ALatch; // Fire
    a_fire_latch_inverter_ = new AInverter( *a_fire_latch_, 3.4, 0.3 ); // 7400 (actually a NAND gate)
    a_fire_control_ = new AGalaxianFireControl( a_fire_latch_inverter_, a_noise_ ); // R46, R47, R48, C28, C29
    a_fire_timer_ = new ATimer555Astable( Kilo(10), Kilo(22), Micro(0.01) ); // R44, R45, C27
    a_fire_timer_->setControl( a_fire_control_, 1.0 );
    a_fire_diode_ = new AClipperLo( *a_fire_latch_, 0.7 ); // D2 (4148 diode)
    a_fire_ = new ACapacitorWithSwitch( *a_fire_diode_, *a_fire_timer_, Kilo(1), Kilo(100), Micro(1) ); // R41, C25

    // Note: the above diodes cause a voltage drop of about 0.7 volts, but that doesn't
    // change the signal shape much, only the amplitude. Since amplitude is handled later
    // anyway, emulation here is only concerned with preventing the discharge of capacitors.

    a_fs_control_current_ = new ALatch(); // Current out of Q2
    a_fs_control_ = new ATimer555LinearRamp( Micro(1) ); // C15
    a_fs_control_->setCurrent( a_fs_control_current_ );
    a_fs_control_amp_ = new AOpAmp_NonInv1( *a_fs_control_, Kilo(47), Kilo(47), Kilo(33), 5.0 ); // R31, R32, R33, LM324
    a_fs_control_res_[0] = 0.3;
    a_fs_control_res_[1] = 0.3;
    a_fs_control_res_[2] = 0.3;
    a_fs_control_res_[3] = 0.3;

    a_fs_[0] = new ATimer555Astable( Kilo(100), Kilo(470), Micro(0.01) ); // R22, R23, C17
    a_fs_[1] = new ATimer555Astable( Kilo(100), Kilo(330), Micro(0.01) ); // R25, R26, C18
    a_fs_[2] = new ATimer555Astable( Kilo(100), Kilo(220), Micro(0.01) ); // R28, R29, C19
    
    for( int i=0; i<3; i++ ) {
        a_fs_[i]->setControl( a_fs_control_amp_, 1.0 );
        a_fs_[i]->setReset( true );
    }

    // Initialize the tone generator emulation
    tone_pitch_ = 0xFF;
    tone_volume_ = 0;
    tone_offset_ = 0;
    tone_output_ = 0;
    tone_counter_ = 0;

    // Tone is generated by a 74393 4-bit counter, connected to an external
    // clock (pitch) and a couple of 4066 switches for volume control

    double R49 = 10; // Bit 2, controlled by bit 0 of tone volume
    double R50 = 22; // Bit 2
    double R51 = 33; // Bit 0
    double R52 = 15; // Bit 3, controlled by bit 1 of tone volume

    double maxOutput = 1/R49 + 1/R50 + 1/R51 + 1/R52;

    // Precalculate the output waveform for each possible step and volume
    for( int volume=0; volume<4; volume++ ) {
        double i_out[4];
        
        i_out[0] = 1/R51;
        i_out[1] = 0;       // Not connected
        i_out[2] = 1/R50 + (volume & 0x01) ? 1/R49 : 0;
        i_out[3] = (volume & 0x02) ? 1/R52 : 0;

        for( int output=0; output<16; output++ ) {
            double c = 0;

            if( output & 0x01 ) c += i_out[0];
            if( output & 0x02 ) c += i_out[1];
            if( output & 0x04 ) c += i_out[2];
            if( output & 0x08 ) c += i_out[3];

            c /= maxOutput;

            tone_volume_table_[volume][output] = (int) (c * 255);
        }
    }
}

GalaxianSoundBoard::~GalaxianSoundBoard()
{
    delete a_noise_;

    delete a_hit_latch_; 
    delete a_hit_;
    delete a_hit_diode_;
    delete a_hit_filter_;

    delete a_fire_latch_;  
    delete a_fire_diode_;
    delete a_fire_latch_inverter_;
    delete a_fire_control_;
    delete a_fire_timer_;  
    delete a_fire_;

    delete a_fs_[0];
    delete a_fs_[1];
    delete a_fs_[2];
    delete a_fs_control_current_;
    delete a_fs_control_;
    delete a_fs_control_amp_;
}

void GalaxianSoundBoard::startFrame()
{
    a_fire_->resetStream();
    a_hit_filter_->resetStream();

    a_fs_[0]->resetStream();
    a_fs_[1]->resetStream();
    a_fs_[2]->resetStream();
}

void GalaxianSoundBoard::endFrame( unsigned offset )
{
    // Update all the voices
    a_fire_->updateTo( offset );
    a_hit_filter_->updateTo( offset );

    a_fs_[0]->updateTo( offset );
    a_fs_[1]->updateTo( offset );
    a_fs_[2]->updateTo( offset );
}

void GalaxianSoundBoard::playFrame( int * buffer, unsigned bufsize )
{
    // Play the tone generator
    if( tone_pitch_ != 0xFF ) {
        unsigned period = (256 - tone_pitch_) << 6;

        unsigned step = (ToneGeneratorClock << 10) / ASE::samplingRate;

        unsigned volume = tone_volume_;
        unsigned offset = tone_offset_;
        unsigned output = tone_output_;

        for( unsigned n=0; n<bufsize; n++ ) {
            buffer[n] += tone_volume_table_[volume][output];

            offset += step;

            if( offset >= period ) {
                offset -= period;
                output = (output + 1) & 0x0F;
            }
        }

        tone_offset_ = offset;
        tone_output_ = output;
    }

    // Play the "background" voices
    a_fs_[0]->mixStream( buffer, 20 );
    a_fs_[1]->mixStream( buffer, 20 );
    a_fs_[2]->mixStream( buffer, 20 );

    // Play the special effects
    a_fire_->mixStream( buffer, 51 );
    a_hit_filter_->mixStream( buffer, 51, 0, 255 ); // Noise must be clipped
}

void GalaxianSoundBoard::writeToLatch9L( unsigned currentTimeInSamples, unsigned offset, unsigned char value )
{
    value &= 1;

    bool enabled = value != 0;

    switch( offset ) {
    case 4:
    case 5:
    case 6:
    case 7:
        // Sweepers control
        {
            a_fs_control_current_->updateTo( currentTimeInSamples );

            a_fs_control_res_[offset - 4] = enabled ? 3.4 : 0.3;

            double R0 = 1.0 / Mega(1);      // R18
            double R1 = 1.0 / Kilo(470);    // R17
            double R2 = 1.0 / Kilo(220);    // R16
            double R3 = 1.0 / Kilo(100);    // R15
            double RG = 1.0 / Kilo(300);    // R14 (this is labeled R16 again in the schematics)
            double Ri;
            double Vi = 0;

            Ri = 1.0 / (R1 + R2 + R3 + RG);
            Vi += a_fs_control_res_[0] * (Ri / (1.0/R0 + Ri));

            Ri = 1.0 / (R0 + R2 + R3 + RG);
            Vi += a_fs_control_res_[1] * (Ri / (1.0/R1 + Ri));

            Ri = 1.0 / (R0 + R1 + R3 + RG);
            Vi += a_fs_control_res_[2] * (Ri / (1.0/R2 + Ri));

            Ri = 1.0 / (R0 + R1 + R2 + RG);
            Vi += a_fs_control_res_[3] * (Ri / (1.0/R3 + Ri));

            double Vcc = 5.0;
            double Vbe = 0.7;
            double Re = Kilo(100);
            double Ve = Vbe + Vi;
    
            double Ic = (Vcc - Ve) / Re;

            // TODO: at this point we should have the current out of Q2 but...
            // does all of that go to charge the capacitor? I don't think so
            // but currently I'm not able to compute the exact value... :-(
            // Until then, and considering that I don't have the real hardware
            // to perform tests, the following seems to sound reasonably good.
            Ic *= 0.30;

            a_fs_control_current_->setValue( Ic );
        }
        break;
    }
}

void GalaxianSoundBoard::writeToLatch9M( unsigned currentTimeInSamples, unsigned offset, unsigned char value )
{
    value &= 1;

    bool enabled = value != 0;

    switch( offset ) {
    case 0:
        // FS generator #1
        a_fs_[0]->updateTo( currentTimeInSamples );
        a_fs_[0]->setReset( ! enabled );
        break;
    case 1:
        // FS generator #2
        a_fs_[1]->updateTo( currentTimeInSamples );
        a_fs_[1]->setReset( ! enabled );
        break;
    case 2:
        // FS generator #3
        a_fs_[2]->updateTo( currentTimeInSamples );
        a_fs_[2]->setReset( ! enabled );
        break;
    case 3:
        // Hit circuit
        a_hit_latch_->updateTo( currentTimeInSamples );
        a_hit_latch_->setValue( enabled ? 3.4 : 0.3 );
        break;
    case 5:
        // Fire circuit
        a_fire_latch_->updateTo( currentTimeInSamples );
        a_fire_latch_->setValue( enabled ? 3.4 : 0.3 );
        break;
    case 6:
        // Tone volume (bit 0)
        tone_volume_ = (tone_volume_ & ~0x01) | value;
        break;
    case 7:
        // Tone volume (bit 1)
        tone_volume_ = (tone_volume_ & ~0x02) | (value << 1);
        break;
    }
}
